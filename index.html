<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GPS表示・記録</title>
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
     integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
     crossorigin=""/>

    <style>
        body, html {
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.6;
            background-color: #f4f4f4;
            color: #333;
            display: flex;
            flex-direction: column;
            overflow: hidden; /* 全体のスクロールを禁止 */
        }
        .controls-panel {
            padding: 10px;
            background-color: #ffffff;
            border-bottom: 1px solid #ccc;
            text-align: center;
            box-sizing: border-box;
            flex-shrink: 0; /* パネルが縮まないようにする */
        }
        .controls-panel h1 {
            font-size: 1.5em;
            margin: 0 0 15px 0;
            color: #2c3e50;
        }
        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin-bottom: 10px;
        }
        button {
            padding: 10px 20px;
            border: none;
            background-color: #007bff;
            color: white;
            cursor: pointer;
            border-radius: 5px;
            font-size: 1em;
            transition: background-color 0.2s ease;
        }
        button.red-button { background-color: #dc3545; }
        button.red-button:hover { background-color: #c82333; }
        button.green-button { background-color: #28a745; }
        button.green-button:hover { background-color: #218838; }
        button:hover { background-color: #0056b3; }
        button:disabled {
            background-color: #d0d0d0;
            color: #777;
            cursor: not-allowed;
        }
        #statusMessage {
            margin-top: 5px;
            font-size: 0.9em;
            color: #555;
            text-align: center;
            min-height: 1.2em;
        }
        #map {
            flex-grow: 1; /* 残りのスペースを全て使用する */
            width: 100%;
        }
        .settings-group {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 15px;
            margin-top: 5px;
            margin-bottom: 10px;
        }
        .input-group {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .input-group label { font-size: 0.9em; color: #555; }
        .input-group input[type="number"] {
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 3px;
            width: 60px;
            text-align: right;
        }
        #pointCount { font-weight: bold; color: #007bff; }

        #last-point-display {
            margin-top: 10px;
            padding: 8px;
            background-color: #e9ecef;
            border-radius: 4px;
            font-family: "SF Mono", "Consolas", "Courier New", monospace;
            font-size: 0.85em;
            text-align: left;
            width: 95%;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
            box-sizing: border-box;
            white-space: nowrap;
            overflow-x: auto;
            color: #495057;
            min-height: 1.5em;
        }

        @media (max-width: 600px) {
            .controls-panel h1 { font-size: 1.2em; margin-bottom: 10px; }
            .button-group { width: 95%; margin-left: auto; margin-right: auto; gap: 5px; }
            button { padding: 8px 12px; font-size: 0.9em; flex-grow: 1; min-width: 120px; }
            .settings-group { width: 95%; margin: 5px auto; gap: 10px; flex-direction: column; }
            .input-group input[type="number"] { padding: 4px; width: 50px; }
            #statusMessage { font-size: 0.8em; margin: 2px 0; }
            .controls-panel { padding: 8px; }
        }
    </style>
</head>
<body>
    <div class="controls-panel">
        <h1>GPS表示・記録 Ver1.00</h1>
        <div class="button-group">
            <button id="getLocationButton">現在地を表示</button>
            <button id="startRecordingButton" class="green-button">記録開始</button>
            <button id="stopRecordingButton" class="red-button" disabled>記録終了</button>
        </div>
        <div class="settings-group">
            <div class="input-group">
                <label for="recordingInterval">記録間隔:</label>
                <input type="number" id="recordingInterval" value="15" min="1">
                <span>秒</span>
            </div>
            <div class="input-group">
                <label>記録ポイント数:</label>
                <span id="pointCount">0</span>
            </div>
        </div>
        <div id="statusMessage">現在地を表示するか、記録を開始してください。</div>
        <div id="last-point-display">記録を開始すると、ここに最新のデータが表示されます。</div>
    </div>
    <div id="map"></div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const map = L.map('map').setView([34.613379, 135.493023], 15);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(map);

            const getLocationButton = document.getElementById('getLocationButton');
            const startRecordingButton = document.getElementById('startRecordingButton');
            const stopRecordingButton = document.getElementById('stopRecordingButton');
            const recordingIntervalInput = document.getElementById('recordingInterval');
            const statusMessage = document.getElementById('statusMessage');
            const pointCountDisplay = document.getElementById('pointCount');
            const lastPointDisplay = document.getElementById('last-point-display');

            let currentLocationMarker = null;
            let watchId = null;
            let recordingTimerId = null;
            let latestPosition = null;
            let isRecording = false;
            let isGpsTrackingActive = false;
            let recordedTrackPoints = [];
            let recordingIntervalSeconds = parseInt(recordingIntervalInput.value, 10) || 15;

            const updateButtonStates = () => {
                getLocationButton.disabled = isGpsTrackingActive;
                startRecordingButton.disabled = isRecording || !navigator.geolocation;
                stopRecordingButton.disabled = !isRecording;
                recordingIntervalInput.disabled = isRecording;
            };

            const _startGpsTracking = () => {
                if (!navigator.geolocation) {
                    alert('お使いのブラウザは位置情報サービスに対応していません。');
                    return;
                }
                if (!isGpsTrackingActive) {
                    watchId = navigator.geolocation.watchPosition(onPositionSuccess, onPositionError, geolocationOptions);
                    isGpsTrackingActive = true;
                }
            };

            const _stopGpsTracking = () => {
                if (!isRecording && isGpsTrackingActive) {
                    if (watchId !== null) navigator.geolocation.clearWatch(watchId);
                    watchId = null;
                    isGpsTrackingActive = false;
                }
            };

            const onPositionSuccess = (position) => {
                latestPosition = position;
                const { latitude: lat, longitude: lon, accuracy } = position.coords;
                const currentLatLng = [lat, lon];
                
                if (currentLocationMarker) {
                    currentLocationMarker.setLatLng(currentLatLng);
                } else {
                    currentLocationMarker = L.marker(currentLatLng).addTo(map).bindPopup("現在地");
                }
                currentLocationMarker.getPopup().setContent(`現在地<br>精度: 約 ${accuracy.toFixed(0)} m`).update();
                
                if (!isRecording) {
                    map.setView(currentLatLng, 16);
                    statusMessage.textContent = `現在地: 緯度 ${lat.toFixed(6)}, 経度 ${lon.toFixed(6)}`;
                }
            };

            const onPositionError = (error) => { console.error(error); statusMessage.textContent = '位置情報の取得に失敗しました。';};
            const geolocationOptions = { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 };

            // ★★★ 修正された記録ロジック ★★★
            const recordPoint = () => {
                if (!isRecording || !latestPosition) return;

                const { latitude, longitude, altitude } = latestPosition.coords;
                // ★ タイムスタンプはGPS情報からではなく、記録した瞬間の現在時刻を生成する
                const pointData = { 
                    lat: latitude, 
                    lon: longitude, 
                    ele: altitude, 
                    time: new Date().toISOString() 
                };

                recordedTrackPoints.push(pointData);

                // UIの更新
                const pointNumber = recordedTrackPoints.length;
                pointCountDisplay.textContent = pointNumber;
                const altitudeStr = pointData.ele !== null ? `Alt: ${pointData.ele.toFixed(1)}m` : 'Alt: N/A';
                const timeStr = new Date(pointData.time).toLocaleTimeString('ja-JP');
                lastPointDisplay.textContent = `#${pointNumber} | Lat: ${pointData.lat.toFixed(6)} | Lon: ${pointData.lon.toFixed(6)} | ${altitudeStr} | ${timeStr}`;
                statusMessage.textContent = `記録中... ${pointNumber} ポイント`;
            };

            // ★★★ ファイル保存処理 (フィルターなしの単純な保存) ★★★
            const saveGpxTrack = () => {
                if (recordedTrackPoints.length === 0) {
                    return 0;
                }
                const now = new Date();
                const jstDate = new Date(now.toLocaleString('en-US', { timeZone: 'Asia/Tokyo' }));
                const yyyy = jstDate.getFullYear();
                const mm = String(jstDate.getMonth() + 1).padStart(2, '0');
                const dd = String(jstDate.getDate()).padStart(2, '0');
                const hh = String(jstDate.getHours()).padStart(2, '0');
                const min = String(jstDate.getMinutes()).padStart(2, '0');
                const filename = `${yyyy}${mm}${dd}_${hh}${min}.gpx`;
                let gpxContent = `<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="GPS表示・記録" xmlns="http://www.topografix.com/GPX/1/1" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd">
<metadata><name>GPS履歴 ${yyyy}${mm}${dd} ${hh}:${min} (JST)</name></metadata>
<trk><name>記録トラック</name><trkseg>\n`;
                
                // ★ recordedTrackPoints 配列をそのまま全部記録する
                recordedTrackPoints.forEach(point => {
                    gpxContent += `    <trkpt lat="${point.lat}" lon="${point.lon}">`;
                    if (point.ele !== null && point.ele !== undefined) {
                        gpxContent += `<ele>${point.ele.toFixed(2)}</ele>`;
                    }
                    gpxContent += `<time>${point.time}</time></trkpt>\n`;
                });
                gpxContent += `  </trkseg></trk>\n</gpx>`;
                const blob = new Blob([gpxContent], { type: 'application/gpx+xml' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                statusMessage.textContent = `GPS履歴を ${filename} として保存しました。`;
                return recordedTrackPoints.length; // 実際に保存したポイント数を返す
            };

            const stopRecording = () => {
                isRecording = false;
                if (recordingTimerId) clearInterval(recordingTimerId);
                recordingTimerId = null;
                _stopGpsTracking();
                
                const savedPointsCount = saveGpxTrack();

                if (savedPointsCount > 0) {
                    lastPointDisplay.textContent = `記録を停止し、${savedPointsCount} ポイントを保存しました。`;
                } else {
                    lastPointDisplay.textContent = '記録データがなかったため、ファイルは保存されませんでした。';
                }
                
                recordedTrackPoints = [];
                updateButtonStates();
            };

            getLocationButton.addEventListener('click', () => {
                statusMessage.textContent = '現在地を取得中...';
                _startGpsTracking();
            });

            startRecordingButton.addEventListener('click', () => {
                if (!navigator.geolocation) { alert('お使いのブラウザは位置情報サービスに対応していません。'); return; }
                recordedTrackPoints = [];
                pointCountDisplay.textContent = '0';
                lastPointDisplay.textContent = '最初のGPS測位を待っています...';
                isRecording = true;
                
                _startGpsTracking();
                if (recordingTimerId) clearInterval(recordingTimerId);
                
                const startTimerWhenReady = () => {
                    if (latestPosition) {
                        // 測位できたら、設定された間隔でタイマーを開始
                        recordingTimerId = setInterval(recordPoint, recordingIntervalSeconds * 1000);
                    } else {
                        setTimeout(startTimerWhenReady, 500); // 測位できるまで待つ
                    }
                };
                startTimerWhenReady();
                updateButtonStates();
            });

            stopRecordingButton.addEventListener('click', stopRecording);

            recordingIntervalInput.addEventListener('change', () => {
                const newValue = parseInt(recordingIntervalInput.value, 10);
                if (newValue >= 1) {
                    recordingIntervalSeconds = newValue;
                    if (isRecording) {
                        statusMessage.textContent = `記録間隔を${recordingIntervalSeconds}秒に変更しました。`;
                        clearInterval(recordingTimerId);
                        recordingTimerId = setInterval(recordPoint, recordingIntervalSeconds * 1000);
                    }
                } else {
                    recordingIntervalInput.value = recordingIntervalSeconds;
                }
            });
            updateButtonStates();
        });
    </script>
</body>
</html>
